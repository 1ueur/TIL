**스택 프레임(Stack Frame)** 은 프로그램에서 선언되는 **로컬 변수와 함수 호출**에 사용됩니다. 스택 프레임을 이해하면 스택에 저장된 함수 파라미터와 함수 로컬 변수 등을 쉽게 파악할 수 있습니다.

## 스택 프레임
스택 프레임이란 ESP(스택 포인터)가 아닌 **EBP(베이스 포인터) 레지스터를 사용하여 스택 내의 로컬 변수, 파라미터, 복귀 주소에 접근하는 기법**입니다.
ESP 레지스터의 값은 프로그램 안에서 수시로 변경되기 때문에 스택에 저장된 변수와 파라미터에 접근하고자 할 때 ESP 값을 기준으로 하면 프로그램을 만들기 힘들고, CPU가 정확한 위치를 참고할 때 어려움이 있습니다.

그렇기 어떤 기준 시점(함수 시작)의 ESP 값을 EBP에 저장하고 이를 함수 내에서 유지시켜 주면, ESP 값이 아무리 변하더라도 EBP를 기준(base)으로 안전하게 해당 함수의 변수와 파라미터, 복귀 주소에 접근할 수 있습니다.
이것이 EBP 레지스터의 베이스 포인터 역할입니다.

스택 프레임을 어셈블리 코드로 보면,

```PUSH EBP``` ; 함수 시작(EBP를 사용하기 전에 기존의 값을 스택에 저장)

```MOV EBP, ESP``` ; 현재의 ESP(스택 포인터) 값을 EBP에 저장

```...``` ; 함수 본체. 여기서 ESP가 변경되더라도 EBP는 변경되지 않기 때문에 안전하게 로컬 변수와 파라미터를 엑세스할 수 있음

```MOV ESP, EBP``` ; ESP를 정리(함수 시작했을 때의 값으로 복원시킴)

```POP EBP``` ; 리턴되기 전에 저장해 놓았던 원래 EBP 값으로 복원

```RETN``` ; 함수 종료

스택 프레임을 이용하여 함수 호출을 관리하면, 아무리 함수 호출 깊이가 깊고 복잡하다해도 스택을 완벽하게 관리할 수 있습니다.

> 최신 컴파일러는 최적화(Optimization) 옵션을 가지고 있어서 간단한 함수는 스택 프레임을 생성하지 않습니다.
> 
> 스택에 복귀 주소가 저장된다는 점은 보안 취약점으로 작용할 수 있습니다. buffer overflow 기법을 사용하여 복귀 주소가 저장된 스택 메모리를 의도적으로 다른 값으로 변경할 수 있습니다.

## StackFrame.exe
### StackFrame.cpp
```cpp
#include "stdio.h"

long add(long a, long b) {
    long x = a, y = b;
    
    return (x + y);
}

int main() {
    long a = 1, b = 2;
    
    printf("%d\n", add(a, b));
    
    return 0;
}
```

OllDbg로 StackFrame.exe 파일을 열고 401000 주소로 이동합니다. **(Go to 명령어 사용[Ctrl+G])**

<img width="646" alt="StackFrame" src="https://user-images.githubusercontent.com/66156026/150468475-181d50fa-521e-4501-a9cd-a48c0ed132bd.png">

### main() 함수 시작 & 스택 프레임 생성
코드 흐름 순서에 맞게 main() 함수부터 시작합니다. main() 함수(401020)에 BP(Break Point)를 설치[F2]한 후 실행[F9]합니다.

main() 함수 시작 시 스택의 상태입니다.

<img width="281" alt="1" src="https://user-images.githubusercontent.com/66156026/150468844-8eebdd3b-c15d-42ea-9a01-bd1175136c16.png">
<br/>
<img width="401" alt="2" src="https://user-images.githubusercontent.com/66156026/150468845-bf016de2-9ee0-4776-935d-5501028e5e63.png">

현재 **ESP = 19FF2C, EBP = 19FF70** 입니다. ESP에 저장된 값 401250은 main() 함수의 실행이 끝난 후 돌아갈 리턴 주소(Return Address)입니다.

main() 함수는 시작하자마자 스택 프레임을 생성합니다.

<img width="547" alt="1" src="https://user-images.githubusercontent.com/66156026/150469218-506820ac-e6e6-4360-8c50-7408abda8ca0.png">

**'PUSH'는 값을 스택에 집어넣는 명령입니다.** ```'EBP 값을 스택에 집어넣어라'``` 라고 해석할 수 있습니다.
main() 함수에서 EBP가 베이스 포인터의 역할을 하게 되기 때문에 EBP가 이전에 가지고 있던 값을 스택에 백업해두기 위한 용도로 사용됩니다.
나중에 main() 함수가 종료(RETN)되기 전에 이 값을 회복시켜 줍니다. 

<img width="547" alt="2" src="https://user-images.githubusercontent.com/66156026/150470605-423906dd-36b9-475e-a784-f6bd5eaca91b.png">

**'MOV'는 데이터를 옮기는 명령입니다.** ```'ESP의 값을 EBP로 옮겨라'``` 라고 해석할 수 있습니다.
이 명령 이후부터는 EBP와 현재 ESP는 같은 값을 가지게 됩니다. 그리고 **main() 함수가 끝날 때까지 EBP 값은 고정**됩니다.
이 뜻은 스택에 저장된 함수 파라미터와 로컬 변수들은 EBP를 통해 접근(Access)하겠다는 것입니다.
401020과 401021 주소의 두 명령어에 의해서 main() 함수에 대한 스택 프레임이 생성되었습니다.(EBP가 세팅되었습니다.)

OllDbg의 스택 창에서 ```마우스 우측 메뉴 - Address - Relative to EBP``` 를 선택합니다. 스택 창에서 EBP의 위치를 확인할 수 있습니다.

<img width="281" alt="1" src="https://user-images.githubusercontent.com/66156026/150471232-ead61785-e128-4d4d-ae7f-ca74b44c3473.png">
<br/>
<img width="463" alt="2" src="https://user-images.githubusercontent.com/66156026/150471403-9efc9ac7-a370-473a-a737-59d77875dbb8.png">

현재 **EBP 값은 19FF28로 ESP와 동일**하고, 19FF28 주소에는 19FF70이라는 값이 저장되어 있습니다. **19FF70은 main() 함수가 시작할 때 EBP가 가지고 있던 초기 값**입니다.

### 로컬 변수 세팅
> long a = 1, b = 2;

스택에 main() 함수의 로컬 변수(a, b)를 위한 공간을 만들고 값을 입력합니다. main() 함수에서 선언된 변수 a, b가 어떻게 스택 메모리에 생성되고 관리되는지 살펴봅니다.

<img width="546" alt="723" src="https://user-images.githubusercontent.com/66156026/150471846-50d382bd-f81f-4363-8975-f0e9822d9209.png">

**'SUB'는 빼기 명령어입니다.** ```'ESP 값에서 8을 빼라'``` 라고 해석할 수 있습니다. 현재 ESP = 19FF28입니다. 

ESP에서 8을 빼는 이유는 무엇일까요? 함수의 로컬 변수는 스택에 저장됩니다. main() 함수의 로컬 변수는 'a'와 'b'입니다. 'a'와 'b'는 long 타입이기 때문에 각각 4바이트 크기를 가집니다.
결국 **이 두 변수를 스택에 저장하기 위해서는 총 8바이트가 필요한 것**입니다. 그래서 ESP에서 8을 빼 두 변수에게 필요한 메모리 공간을 확보(예약)한 것입니다.
이제 main() 함수 내에서 ESP 값이 아무리 변해도 'a'와 'b' 변수를 위한 스택 영역은 훼손되지 않습니다. EBP 값은 main() 함수 내에서 고정이므로 이를 기준으로 삼아 로컬 변수에 엑세스할 수 있습니다.

<img width="546" alt="7231" src="https://user-images.githubusercontent.com/66156026/150472317-52d0a6c0-fd18-4dc7-835b-a767dd332b85.png">

C 언어의 포인터와 같은 개념으로 생각하면 됩니다.

**어셈블리와 C 언어의 포인터 구문 형식**
<table>
<tr><th>어셈블리 언어</th><th>C 언어</th><th>Type casting</th></tr>
<tr><td>DWORD PTR SS:[EBP-4]</td><td>*(DWORD*)(EBP-4)</td><td>DWORD (4 바이트)</td></tr>
<tr><td>WORD PTR SS:[EBP-4]</td><td>*(WORD*)(EBP-4)</td><td>WORD (2 바이트)</td></tr>
<tr><td>BYTE PTR SS:[EBP-4]</td><td>*(BYTE*)(EBP-4)</td><td>BYTE</td></tr>
</table>

> 위 구문에서 SS(Stack Segment)를 표시하는 이유는 해당 메모리가 어떤 세그먼트에 소속되어 있는 지를 표시해주기 위해서 입니다.
> 실제로 32비트 Windows OS에서는 SS(Stack Segment), DS(Data Segment), ES(Extra data Segment)의 값은 모두 0이기 때문에 이런 식으로 세그먼트를 붙여주는 것에 큰 의미는 없습니다.
> ESP와 EBP는 스택을 가리키는 레지스터들이기 때문에 SS 레지스터를 붙여준 것입니다.

위의 MOV 명령어들은 ```'[EBP-4]에는 1을 넣고, [EBP-8]에는 2를 넣어라'``` 라고 해석할 수 있습니다.
즉 [EBP-4]는 로컬 변수 a를 의미하고, [EBP-8]은 로컬 변수 b를 의미합니다. 여기까지 실행한 후의 스택의 상태입니다.

<img width="281" alt="7232" src="https://user-images.githubusercontent.com/66156026/150473331-0d17a979-c593-4369-ba40-15a8423453e5.png">
<br/>
<img width="464" alt="7233" src="https://user-images.githubusercontent.com/66156026/150473334-c3e98abc-3af2-41ff-a0aa-354d7139c916.png">

### add() 함수 파라미터 입력 및 add() 함수 호출
> printf("%d\n", add(a, b));

<img width="545" alt="724" src="https://user-images.githubusercontent.com/66156026/150473620-05052e2b-6f3e-49e8-826b-bf964571fd29.png">

위 어셈블리 코드는 전형적인 함수 호출 과정입니다. 40103C 주소의 CALL 401000 명령어에서 401000 함수가 add() 함수입니다. 
add() 함수는 파라미터로 a와 b를 받습니다. 위 401034~40103B 주소의 코드에서는 변수 a와 b를 스택에 넣고 있습니다.
여기서 파라미터가 C 언어의 소스 코드 입력 순서와는 반대로 스택에 저장된다는 것을 기억해야 합니다.**(파라미터의 역순 저장)**
변수 b[EBP-8]가 스택에 먼저 들어가고 변수 a[EBP-4]가 나중에 들어갑니다.

40103C 주소의 CALL 명령어를 실행하여 add() 함수(401000) 안으로 들어간 이후의 스택 변화입니다.

<img width="281" alt="1" src="https://user-images.githubusercontent.com/66156026/150505063-41f1b9af-7d2f-4e2c-be82-011d8642dbbf.png">
<br/>
<img width="463" alt="2" src="https://user-images.githubusercontent.com/66156026/150505067-cb1fabae-90b8-47ad-a538-f84bba6e02d2.png">

**복귀 주소**

**CALL 명령어가 실행되어 해당 함수로 들어가기 전에 CPU는 무조건 해당 함수가 종료될 때 복귀할 주소(return address)를 스택에 저장합니다.**
코드를 보면 40103C 주소에서 add() 함수를 호출하였고, 그 다음 명령어의 주소는 401041이기 때문에 add() 함수의 실행이 완료되면 401041 주소로 돌아와야 합니다.

<img width="463" alt="3" src="https://user-images.githubusercontent.com/66156026/150506362-59f1fac2-8a45-4030-8042-90e918ce48af.png">

401041 주소가 add() 함수의 복귀 주소입니다.

### add() 함수 시작 & 스택 프레임 생성
> long add(long a, long b) {

**add() 함수가 시작되면 자신만의 스택 프레임을 따로 생성**합니다.

<img width="546" alt="725" src="https://user-images.githubusercontent.com/66156026/150506947-5cbb427d-3b81-4275-9618-e8a309be5fc5.png">

코드는 main() 함수의 스택 프레임을 생성할 때와 완전히 동일합니다.
원래의 EBP 값(main() 함수의 Base Pointer)을 스택에 저장한 후 현재의 ESP(Stack Pointer)를 EBP에 입력합니다.
이제 add() 함수의 스택 프레임이 생성되었습니다. add() 함수 내에서 EBP 값은 고정됩니다.

여기까지 실행 후 스택의 모습입니다.

<img width="281" alt="7251" src="https://user-images.githubusercontent.com/66156026/150508191-98a20944-4d9c-4d47-a5f4-275d23095cea.png">
<br/>
<img width="462" alt="7252" src="https://user-images.githubusercontent.com/66156026/150508198-26bf7f55-b51b-4417-8009-be5ebd8651c1.png">

main() 함수에서 사용되는 EBP 값(19FF28)을 스택에 백업한 후 EBP가 19FF10으로 새롭게 세팅되었습니다.

### add() 함수의 로컬 변수(x, y) 세팅
> long x = a, y = b;

add() 함수의 로컬 변수 x, y에 각각 파라미터 a, b를 대입합니다. 함수 내에서 파라미터와 로컬 변수가 어떤 식으로 표시되는지 확인합니다.

<img width="546" alt="726" src="https://user-images.githubusercontent.com/66156026/150509504-fc86eb9c-54dd-4502-b711-59cdc638c581.png">

