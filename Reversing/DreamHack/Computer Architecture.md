## 컴퓨터 구조
컴퓨터 구조(Computer Architecture)란 컴퓨터가 효율적으로 작동할 수 있도록 HW / SW의 기능을 고안하고 구성하는 방법입니다.

**1. 기능 구조에 대한 설계**
- 컴퓨터가 연산을 효율적으로 하기 위해 어떤 기능들이 컴퓨터에 필요한지 고민하고 설계하는 분야.
- **폰 노이만 구조**, 하버드 구조, 수정된 하버드 구조

**2. 명령어 집합 구조**
- CPU의 명령어에 대한 설계를 명령어 집합 구조(Instruction Set Architecture)라고 하며, CPU가 처리해야하는 명령어를 설계하는 분야.
- 인텔 x86, **인텔 x86-64**, ARM, MIPS, AVR

**3. 마이크로 아키텍처**
- CPU의 하드웨어적 설계를 마이크로 아키텍처(Micro Architecture)라고 하며, 정의된 명령어 집합을 효율적으로 처리할 수 있도록 CPU의 회로를 설계하는 분야.
- 캐시 설계, 파이프라이닝, 슈퍼 스칼라, 분기 예측, 비순차적 명령어 처리

**4. 기타 하드웨어 및 컴퓨팅 방법에 대한 설계**
- 직접 메모리 접근

<br/>

### 폰 노이만 구조
폰 노이만은 초기의 컴퓨터 과학자 중 한 명입니다. 폰 노이만은 컴퓨터에 **연산, 제어, 저장** 세 가지의 핵심 기능이 필요하다고 생각했고, 이는 후의 연산과 제어를 위한 **중앙처리장치(CPU)**, 저장을 위한 **기억장치(Memory)** 가 되었습니다.
이런 장치 간의 데이터나 제어 신호를 교환할 수 있도록 **버스(Bus)** 라는 전자 통로를 사용합니다.

- **중앙처리장치(CPU)** 🧠
  - CPU는 컴퓨터의 두뇌에 해당합니다. 연산을 처리하고 시스템을 제어합니다.
  - 산술/논리 연산을 처리하는 **산술논리장치(ALU), 제어하는 제어장치(Control Unit), 데이터를 저장하는 레지스터(Register)** 등으로 구성됩니다.
- **기억 장치(Memory)** 💾
  - 기억 장치는 컴퓨터가 동작하는데 필요한 여러 데이터를 저장하기 위해 사용되며 용도에 따라 주기억장치와 보조기억장치로 분류됩니다.
  - 주기억장치는 데이터를 임시로 저장하기 위해 사용되며 대표적으로 **램(RAM)** 이 있습니다.
  - 보조기억장치는 데이터를 영구적으로 저장하며 대표적으로 **하드 드라이브(HDD), SSD** 가 있습니다.
- **버스(Bus)** 🚌
  - 버스는 부품과 부품 사이, 컴퓨터와 컴퓨터 사이의 신호를 전송하는 통로입니다.
  - 데이터가 이동하는 **데이터 버스**, 주소를 지정하는 **주소 버스**, 읽기/쓰기를 제어하는 **제어 버스**가 있습니다. 

> CPU 내부에는 주기억장치와 보조기억장치가 아닌 레지스터/캐시 라는 저장장치를 가지고 있습니다.
> CPU의 연산속도는 주기억장치와 보조기억장치와의 데이터 교환속도보다 압도적으로 빠르기 때문에 CPU 내부에 저장장치를 가지게 된 것입니다.

### 명령어 집합 구조
명령어 집합 구조(ISA)란 **CPU가 해석하는 명령어의 집합**입니다. 프로그램의 코드는 기계어로 작성되어 있는데, 프로그램을 실행하면 이 명령어들을 CPU가 읽고 처리합니다.

컴퓨터의 수준과 연산 능력, 환경이 모두 다르기 때문에 다양한 ISA가 존재합니다.
인텔의 ```x86-64```는 **고성능 프로세서**를 설계하기 위해 사용됩니다. 이런 프로세서는 많은 전력과 발열이 상대적으로 심하기 때문에 **데스크톱이나 랩톱**에 사용되고,
크기가 작고 피부에 닿을 수 있는 **임베디드 장치에 경우**, 전력 소모와 발열이 적은 ```ARM```이나 ```MIPS```, ```AVR```의 프로세서를 사용합니다.

### x86-64 아키텍처
x64 아키텍처는 **인텔의 64비트 CPU 아키텍처**입니다. 인텔의 32비트 CPU 아키텍처 IA-32를 64비트 환경에서 사용할 수 있도록 **확장**한 것으로, 대부분의 개인용 컴퓨터들은 인텔의 x64 CPU를 사용합니다.

**n비트 아키텍처**. 여기서 **n은 한 번에 처리할 수 있는 데이터의 크기**를 의미합니다. 이를 CPU가 이해할 수 있는 데이터의 단위라는 의미에서 ```WORD```라고 부릅니다.
일반적인 32비트 아키텍처에서 ALU는 한 번에 32비트 크기의 값을 연산할 수 있고, 대역폭 또한 32비트 크기를 가지고 있습니다. CPU 설계 상 32비트의 데이터까지만 처리할 수 있다는 말입니다.
64비트도 동일합니다.

최근 32비트 아키텍처보다 64비트 아키텍처를 사용하는 이유는 CPU가 제공할 수 있는 **가상 메모리(Virtual Memory)의 크기** 때문입니다. 
32비트 아키텍처에서는 **4기가 바이트**가 최대 제공이 가상한 가상메모리의 크기이고, 64비트 아키텍처에서는 이론상 **16엑사 바이트**의 가상메모리를 제공할 수 있습니다. 
결국 32비트에서는 많은 메모리 자원이 필요한 전문 SW나 고사양 게임을 실행할 때 부족할 수 있지만, 64비트에서는 거의 그런 일이 일어나지 않습니다.

### x86-64 아키텍처 : 레지스터
레지스터는 **CPU 내부의 저장장치**로, CPU가 빠르게 접근하여 사용할 수 있습니다. 레지스터는 산술 안산에 필요한 데이터를 저장하거나 주소를 저장하고 참조하는 등 다양한 용도로 사용됩니다.

(x86-64 기준입니다.)

**1. 범용 레지스터(General Register)**
- 각각의 범용 레지스터는 **8바이트**를 저장할 수 있고, 부호 없는 정수를 기준으로 2^64-1까지 나타낼 수 있습니다.
- 자주 쓰이는 범용 레지스터들의 주 용도입니다.
<table>
<tr><th>이름</th><th>주 용도</th></tr>
<tr><td>rax(accumulator register)</td><td>함수의 반환 값</td></tr>
<tr><td>rbx(base register)</td><td>x64 한정 주된 용도 없음</td></tr>
<tr><td>rcx(counter register)</td><td>반복문의 반복 횟수, 각종 연산의 시행 횟수</td></tr>
<tr><td>rdx(data register)</td><td>x64 한정 주된 용도 없음</td></tr>
<tr><td>rsi(source index)</td><td>데이터를 옮길 때 원본을 가리키는 포인터</td></tr>
<tr><td>rdi(destination index)</td><td>데이터를 옮길 때 목적지를 가리키는 포인터</td></tr>
<tr><td>rsp(stack pointer)</td><td>사용 중인 스택의 위치를 가리키는 포인터</td></tr>
<tr><td>rbp(stack base pointer)</td><td>스택의 바닥을 가리키는 포인터</td></tr>
</table>

**2. 세그먼트 레지스터(Segment Register)**
- cs, ss, ds, es, fs, gs 총 6가지의 세그먼트 레지스터가 존재합니다. 각 레지스터의 크기는 **16비트**입니다.
- 현대의 x64에서 cs, ds, ss 레지스터는 **코드 영역과 데이터, 스택 메모리 영역**을 가리킬 때 사용되고, 나머지 레지스터는 운영체제 별 용도를 결정할 수 있도록 범용적인 용도로 제작되었습니다.

**3. 명령어 포인터 레지스터(Instruction Pointer Register, IP)**
- 프로그램의 코드는 기계어로 작성되어 있는데 이 중에서 **CPU가 어느 부분의 코드를 실행할지 가리키는 것**이 명령어 포인터 레지스터의 역할입니다.
- x64 아키텍처의 명령어 레지스터는 ```rip```이며 크기는 **8바이트**입니다.

**4. 플래그 레지스터(Flag Register)**
- 플래그 레지스터는 **프로세서의 현재 상태를 저장**하고 있는 레지스터입니다.
- x64 아키텍처에서는 ```RFLAGS```라고 불리는 **64비트** 크기의 플래그 레지스터가 존재하며, 과거의 16비트 플래그 레지스터가 확장된 것입니다.
- 깃발을 올리고 내리는 행위로 신호를 전달하듯이, 자신을 구성하는 여러 비트들로 CPU의 현재 상태를 표현합니다.
<table>
<tr><th>플래그</th><th>의미</th></tr>
<tr><td>CF(Carry Flag)</td><td>부호 없는 수의 연산 결과가 비트의 범위를 넘을 경우 설정됩니다.</td></tr>
<tr><td>ZF(Zero Flag)</td><td>연산의 결과가 0일 경우 설정됩니다.</td></tr>
<tr><td>SF(Sign Flag)</td><td>연산의 결과가 음수일 경우 설정됩니다.</td></tr>
<tr><td>OF(Overflow Flag)</td><td>부호 있는 수의 연산 결과가 비트 범위를 넘을 경우 설정됩니다.</td></tr>
</table>

RFLAGS는 64비트이므로 최대 64개의 플래그를 사용할 수 있지만, 실제로는 20여개의 비트만 사용합니다.

> x86-64 아키텍처는 IA-32의 64비트 확장 아키텍처이기 때문에 호환이 가능합니다. 위에서 공부한 레지스터들은 확장된 형태입니다.

### 리뷰 퀴즈
**Q1. rax = 0x0123456789abcdef 일 때, eax, ax, ah, al의 값은?**

(1) eax = ```0x89abcdef```

(2) ax = ```0xcdef```

(3) ah = ```0xcd```

(4) al = ```0xef```

> eax는 rax의 하위 32비트, ax는 eax의 하위 16비트입니다. ah는 ax의 상위 8비트, al은 ax의 하위 8비트를 의미합니다.

**Q2. rax에서 rbx를 뺐을 때, ZF가 설정되었다. rax와 rbx의 대소를 비교하시오.**

rax ```==``` rbx

> ZF는 연산의 결과가 0이 되었을 때 설정되는 플래그입니다. 뺄셈 결과로 ZF가 0이라면 두 피연산자의 값을 동일(==)하다는 의미입니다.