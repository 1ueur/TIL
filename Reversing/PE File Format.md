## PE File Format 이해
- ```PE File Format```은 Windows 실행 파일의 구성 방식입니다.
- Windows에서 동작하는 실행 파일은 어떻게 구성되어야 하는지, 그 원칙을 정의해 놓은 것입니다.
- Windows에서 실행 가능한 모든 파일은 PE 파일 구성에 맞게 작성되어 있습니다.
- PE 파일을 만들 때 보통 개발 도구를 사용합니다. 코드를 작성하면 개발 도구의 컴파일러가 PE File Format에 맞게 실행파일로 만들어 줍니다.

### 컴파일하는 과정
1. 코드와 데이터 분리
2. 명령 코드를 기계어로 변환
3. 문자열 데이터를 아스키 값으로 바꾼다.
4. 명령 코드와 아스키 값을 담기 위한 틀을 만든다.
5. PE 헤더를 채운다. ```PE Header```
6. 명령 코드를 채운다. ```.text Section```
7. 데이터를 채운다. ```.data Section```

### 분석 공부 방향
- PE 헤더는 어떻게 구성되어 있고, 그 값들이 의미하는 바가 무엇인지 알아야 합니다.
- .text 섹션에 기록되는 명령 코드를 읽을 줄 알아야 합니다.
- .data 섹션에 기록되는 데이터가 무슨 값인지 알아야 합니다.

### 데이터 표기 방식
- 데이터는 ```데이터의 종류```, ```데이터 표기 방식``` 이 2가지 기준을 가지고 접근합니다.

```1. 데이터의 종류```
- 데이터는 숫자와 문자로 구성되어 있습니다.
```
PUSH 0x4E000
CALL DOWRD PTR DS:[0x00400000]
```
- PUSH 명령어의 뒤어는 상수 값을 가지고, CALL 명령어의 [] 안에는 주소 값이 들어갑니다.
- 0x4E000은 상수, 0x00400000은 주소 정보라는 것을 알 수 있습니다.
- 데이터는 어떻게 쓰이냐에 따라 그 성질이 결정됩니다.


- 문자의 경우 "0x53"은 16진수 데이터이지만, 문자 출력 코드를 거치면 대문자 'S'가 출력됩니다.
- 문자는 아스키 코드와 유니코드 체계입니다.
- 아스키 코드표를 참고하여 숫자를 문자로 바꾸어 확인해볼 수 있습니다.

```2. 데이터 표기 방식```
- 데이터의 표기 방식에는 ```리틀 엔디안 표기법```과 ```빅 엔디안 표기법```으로 구분 지을 수 있습니다.
- 이 둘을 구분 짓는 이유는 CPU 제조사에 따라 데이터를 기록하는 방식에 차이가 있기 때문입니다.
- 많이 쓰는 인텔 CPU는 ```리틀 엔디안 표기법```을 사용합니다. 값을 역순으로 기록하는 방식입니다.
- 여기서 우리는 CPU가 값을 어떻게 기록하는지 보다 이값을 어떻게 읽어야 하는지를 아는 것이 더 중요합니다. 숫자는 반대로 읽고 문자는 그대로 읽으면 됩니다.

<table>
<tr><th>Address</th><th>Hex dump</th></tr>
<tr><td>00406000</td><td>2E 42 65 00 00 00 00 00 00 00 00 00 00 00 00 00</td></tr>
</table>

0x00406000 주소에 4바이트 데이터가 기록되어 있습니다. 이 값은 숫자이기에 **0x0065422E** 라고 읽습니다.

만약, 이 값이 문자 였다면 
<table>
<tr><th>Hex</th><td>2E</td><td>42</td><td>65</td><td>00</td></tr>
<tr><th>Symbol</th><td>.</td><td>B</td><td>e</td><td>NULL</td></tr>
</table>

문자열 **.Be** 가 되고 마지막 1byte는 NULL을 의미하게 됩니다. NULL은 문자열이 끝났다는 정도로 이해할 수 있습니다.

## PE 헤더 훑어보기
PE 헤더는 작은 구조체들이 모여서 만들어진 데이터 덩어리입니다.
PE 헤더는 크게 ```DOS Header```와 ```DOS Stub```, ```NT Header```, ```Section Headers```로 구성되어 있습니다.

<table>
<tr><th>DOS Header</th><td>DOS Header는 DOS와 호환성을 위해서 만들었습니다. 파일의 처음에 위치하고 0x40 크기를 가집니다.</td></tr>
<tr><th>DOS Stub</th><td>PE 파일이 MS-DOS에서 실행될 경우, 화면에 출력될 메시지와 코드가 기록되어 있습니다. DOS Stub은 옵션이기 때문에 파일 실행에 영향이 없으며 크기가 일정하지 않고, 없어도 되는 영역입니다.</td></tr>
<tr><th>NT Header</th><td>파일 실행에 필요한 전반적인 정보를 가지고 있습니다. 0xF8 크기를 가집니다.</td></tr>
<tr><th>Section Header</th><td>각 섹션의 속성 정보를 가지고 있습니다.</td></tr>
</table>

### DOS Header
- PE File Format은 당시 널리 사용되던 DOS 파일에 대한 하위 호환성을 고려해서 만들어졌습니다.
- 그 결과, PE 헤더의 제일 앞부분에는 DOS Header가 존재합니다.
- DOS Header는 IMAGE_DOS_HEADER 구조체에 값을 채워서 만든 것입니다. 크기는 0x40입니다.

### DOS Stub
- DOS Stub은 16비트 명령코드와 데이터의 혼합으로 이루어져 있습니다.
- DOS Stub의 존재 여부는 옵션이고, 크기도 일정하지 않습니다.
- DOS Stub이 없어도 파일 실행에는 문제가 없습니다.

### NT Header
- NT Header는 파일 실행에 필요한 전반적인 정보를 가지고 있습니다.
- 총 3개의 멤버로 구성되어 있습니다.
    - **PE Signature** : NT 헤더의 첫 번째 값은 PE 시그니처입니다. 이 파일은 PE 파일이라는 것을 명시해놓았습니다. PE 로더는 이 값을 보고 올바른 PE 파일인지 확인합니다.
    - **File Header** : File Header는 파일의 물리 정보를 가지고 있습니다. IMAGE_FILE_HEADER 구조체에 값을 채워서 만들어집니다.
    - **Optional Header** : Optional Header는 파일의 논리 정보를 가지고 있습니다. IMAGE_OPTIONAL_HEADER32 구조체에 값을 채워서 만들어집니다. 일반적으로 export table과 import table의 크기와 위치 정보는 Data Directories에 기록되어 있다는 정도만 알면 됩니다.

## Section Header
- Section Header는 PE 파일이 가지는 섹션 수만큼 존재합니다.

```
VA(Virtual Address) VS RVA(Relative Virtual Address)
특정 값의 위치 정보를 표현할 때, OffSet(파일에서의 위치)와 VA(메모리에서의 위치), RVA(메모리에서의 상대 위치)를 사용합니다.
Section Header에서의 RVA는 메일이 메모리에 올라간 시점에서, 파일의 시작 주소를 기준으로 떨어져 있는 상대 위치입니다.
VA는 Image Base 값과 RVA 값을 더하면 구할 수 있습니다.
```

## IAT와 EAT
<table>
<tr><th>항목</th><th>설명</th></tr>
<tr><td>IAT(Import Address Table)</td><td>DLL이 제공하는 함수들 중에서 사용하는 것들에 대한 정보를 기술해 놓은 테이블</td></tr>
<tr><td>EAT(Export Address Table)</td><td>DLL 자신이 서비스하는 함수에 대한 정보를 기술해 놓은 테이블</td></tr>
</table>

```CALL DOWRD PTR DS:[0x00405000]``` 코드는 0x00405000 주소에 기록되어 있는 4byte 주소 값을 호출한다는 의미입니다.

여기서 0x00405000은 IAT 영역이고, 0x00405000 주소로 이동해보면 Beep() API 호출 주소가 있습니다.

API 호출 주소를 IAT에 기록하는 것은 PE 로더에서 담당합니다. PE 로더는 파일을 메모리에 올리는 과정에서 필요한 DLL을 같이 로드하고, 해당 DLL이 Export하는 API들 중에서 필요한 API의 호출 주소를 알아낸 다음 IAT에 기록합니다.

