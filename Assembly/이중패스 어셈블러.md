## 이중패스 어셈블러
### 이중패스의 필요성 (내부 기호 처리)
**① 전 향 참조** (정의문이 뒤에 나와도 된다.) <br/>
기호가 정의되어 있지 않은 상태에서 기호를 이용하는 것이다. <br/>
예시)
```assembly
MOV AX, FOUR
ADD AX, FIVE
MOV SUM, AX

FOUR DW 4
FIVE DW 5
SUM DW ?
```

- 전향 참조는 먼저 기호 값을 알아야 하기 때문에 한꺼번에 번역할 수 없다.
- 이중 패스로 나누어
  - 패스1 : 각 기호의 값(주소)만을 결정
  - 패스2 : 결정된 각 기호 값(주소)을 이용하여 번역을 완성

**② 후 향 참조** (정의문이 앞에 나와야 한다.) <br/>
기호가 정의된 후에 이용되기 때문에 문제가 없다.

### 이중패스 어셈블러의 기능

![22_시프_11주_3교시_6장어셈블러설계_2-10](https://user-images.githubusercontent.com/66156026/172056161-b9885e90-96dc-499e-b810-1546badff1b7.jpg)

### 이중패스 어셈블 과정
**(1) 패스 1의 기능**
- **명령어표, 지시어표 참조**
- **명령어들의 상대주소 결정** (LC:위치계수기 참조)
- **기호표 작성** (링커에게 제공)
- **기호의 재배치 여부 결정** (로더에게 제공)
- 리터럴표 작성
- 오류 정보 출력

**① 명령어의 상대주소** (LC = 0)

상대주소|원시 코드
:---:|:---:|
0|```MOV AX, FOUR``` 👉🏻 LC = 2
2|```ADD AX, FIVE``` 👉🏻 LC = 4
4|```MOV SUM, AX``` 👉🏻 LC = 6
6|```FOUR DW 4``` 👉🏻 LC = 8
8|```FIVE DW 5``` 👉🏻 LC = 10
10|```SUM DW ?``` 👉🏻 LC = 12
-|```END```

**② 기호표 생성**

기호|값(상대주소)|재배치 여부
:---:|:---:|:---:|
```FOUR```|6|1(재배치)
```FIVE```|8|1(재배치)
```SUM```|10|1(재배치)

<br/>

**(2) 패스 2의 기능**
- 명령어 자체를 2진 코드(기계어 코드)로 대체
- 명령어의 기호 대신 기호 표에서 찾은 값으로 대체

**① 변역된 코드의 형태(코드 표)**

상대주소|번역된 코드(연상기호)
:---:|:---:|
0|```MOV AX, 6```
2|```ADD AX, 8```
4|```MOV 10, AX```
6|```4```
8|```5```
10|```-```

**② 기억장치에 적재된 모양** <br/>
- 실제 주소로 바뀐다.

![22_시프_11주_3교시_6장어셈블러설계_2-16](https://user-images.githubusercontent.com/66156026/172614594-4149f472-450b-470e-8c67-2242af9d737a.jpg)

<br/>

## 이중패스 어셈블러의 설계
### 패스 1과 패스 2의 역할
- **명령어 처리**
  - 기호 표 작성
    - 기호 표가 있으면 그 기호 명과 기호의 값을 기호표에 저장
  - 명령어에 상응하는 기계 코드 생성
    - 명령어에 해당하는 2진 기계 코드를 명령어 표에서 찾아 목적 코드로 만든다.
  - **기호**를 **기호 값(상대주소)** 으로 **대체**
    - 명령어 연산 항에 기호가 있으면 기호 표에서 찾아 그 기호의 값으로 바꾸어 준다.

- **어셈블러 지시어 처리**
  - 지시어 표 지시대로 처리
    - 지시어가 있으면 지시어 표에서 해야 할 일을 찾아 그에 따라 처리
    - 예 : DW에 대해서는 데이터를 저장하고 END에 대해서는 어셈블 작업을 끝낸다. 지시어 작업은 보통 이 지시어에 해당되는 서브 루틴을 호출하여 처리한다.

<br/>

**1) 패스 1의 기능**
- **명령어 표를 참조**
  - 윈시 프로그램의 각 명령어나 데이터들의 **상대 주소**를 정한다.
  - **위치 계수기**라는 변수를 이용하여 **LC**에 명령어의 위치를 증가시킴으로 가능.
- **명령어들의 상대 주소 결정**
  - 각 기호 표를 만들어 각 **기호의 값(상대주소)을 기록**.
- **기호의 재배치 여부 결정**
  - 재배치할 기호를 결정하여 **재배치 여부를 표시**

**2) 패스 2의 기능**
- **명령어 자체를 2진 코드로 대체**
  - **명령어 표**에서 각 명령어의 2진 코드를 찾아 **기계어 코드 생성**
- **명령어의 기호 대신 기호 표에서 찾은 값으로 대체**
  - 기호의 전향 참조가 있을 때는 기호의 값(주소 값)을 찾아 기호 대신 기호 값을 기입.

<br/>

- 어셈블리어 지시어가 ```EQU``` 일 때는 **LC**의 값을 증가 시키지 않는다.
- ```EQU```에 의해 기호 값이 정해지면 이 기호는 기억 장소를 차지 하지 않기 때문이다.

### 자료 구조
**(1) 패스 1이 실행되기 위해서 필요한 입출력 자료 (데이터베이스)**

입력|출력
:---:|:---:|
원시 프로그램<br/>위치계수기(변수)<br/>어셈블러 지시어 & 명령어 표|기호표<br/>오류 정보<br/>원시 프로그램 사본

- 위치 계수기(LC) : 명령어의 주소를 헤아리기 위한 변수
- **기호 표** : 프로그램에 나타난 기호와 정의된 기호의 값을 알기 위해 사용되는 변수

**(2) 패스 2가 실행되기 위해서 필요한 입출력 자료 (데이터베이스)**

입력|출력
:---:|:---:|
원시 프로그램<br/>위치계수기(변수)<br/>어셈블러 지시어 & 명령어 표<br/>기호표|목적 프로그램<br/>오류 정보

- **기호 표** : 프로그램에 나타난 기호와 정의된 기호의 값을 알기 위해 사용되는 변수
- 목적 프로그램 : 번역된 기계어 코드

