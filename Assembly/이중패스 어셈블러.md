## 이중패스 어셈블러
### 이중패스의 필요성 (내부 기호 처리)
**① 전 향 참조** (정의문이 뒤에 나와도 된다.) <br/>
기호가 정의되어 있지 않은 상태에서 기호를 이용하는 것이다. <br/>
예시)
```assembly
MOV AX, FOUR
ADD AX, FIVE
MOV SUM, AX

FOUR DW 4
FIVE DW 5
SUM DW ?
```

- 전향 참조는 먼저 기호 값을 알아야 하기 때문에 한꺼번에 번역할 수 없다.
- 이중 패스로 나누어
  - 패스1 : 각 기호의 값(주소)만을 결정
  - 패스2 : 결정된 각 기호 값(주소)을 이용하여 번역을 완성

**② 후 향 참조** (정의문이 앞에 나와야 한다.) <br/>
기호가 정의된 후에 이용되기 때문에 문제가 없다.

### 이중패스 어셈블러의 기능

![22_시프_11주_3교시_6장어셈블러설계_2-10](https://user-images.githubusercontent.com/66156026/172056161-b9885e90-96dc-499e-b810-1546badff1b7.jpg)

### 이중패스 어셈블 과정
**(1) 패스 1의 기능**
- **명령어표, 지시어표 참조**
- **명령어들의 상대주소 결정** (LC:위치계수기 참조)
- **기호표 작성** (링커에게 제공)
- **기호의 재배치 여부 결정** (로더에게 제공)
- 리터럴표 작성
- 오류 정보 출력

**① 명령어의 상대주소** (LC = 0)

상대주소|원시 코드
:---:|:---:|
0|```MOV AX, FOUR``` 👉🏻 LC = 2
2|```ADD AX, FIVE``` 👉🏻 LC = 4
4|```MOV SUM, AX``` 👉🏻 LC = 6
6|```FOUR DW 4``` 👉🏻 LC = 8
8|```FIVE DW 5``` 👉🏻 LC = 10
10|```SUM DW ?``` 👉🏻 LC = 12
-|```END```

**② 기호표 생성**

기호|값(상대주소)|재배치 여부
:---:|:---:|:---:|
```FOUR```|6|1(재배치)
```FIVE```|8|1(재배치)
```SUM```|10|1(재배치)

<br/>

**(2) 패스 2의 기능**
- 명령어 자체를 2진 코드(기계어 코드)로 대체
- 명령어의 기호 대신 기호 표에서 찾은 값으로 대체

**① 변역된 코드의 형태(코드 표)**

상대주소|번역된 코드(연상기호)
:---:|:---:|
0|```MOV AX, 6```
2|```ADD AX, 8```
4|```MOV 10, AX```
6|```4```
8|```5```
10|```-```

**② 기억장치에 적재된 모양** <br/>
- 실제 주소로 바뀐다.

![22_시프_11주_3교시_6장어셈블러설계_2-16](https://user-images.githubusercontent.com/66156026/172614594-4149f472-450b-470e-8c67-2242af9d737a.jpg)

<br/>

## 이중패스 어셈블러의 설계
### 패스 1과 패스 2의 역할
- **명령어 처리**
  - 기호 표 작성
    - 기호 표가 있으면 그 기호 명과 기호의 값을 기호표에 저장
  - 명령어에 상응하는 기계 코드 생성
    - 명령어에 해당하는 2진 기계 코드를 명령어 표에서 찾아 목적 코드로 만든다.
  - **기호**를 **기호 값(상대주소)** 으로 **대체**
    - 명령어 연산 항에 기호가 있으면 기호 표에서 찾아 그 기호의 값으로 바꾸어 준다.

- **어셈블러 지시어 처리**
  - 지시어 표 지시대로 처리
    - 지시어가 있으면 지시어 표에서 해야 할 일을 찾아 그에 따라 처리
    - 예 : DW에 대해서는 데이터를 저장하고 END에 대해서는 어셈블 작업을 끝낸다. 지시어 작업은 보통 이 지시어에 해당되는 서브 루틴을 호출하여 처리한다.

<br/>

**1) 패스 1의 기능**
- **명령어 표를 참조**
  - 윈시 프로그램의 각 명령어나 데이터들의 **상대 주소**를 정한다.
  - **위치 계수기**라는 변수를 이용하여 **LC**에 명령어의 위치를 증가시킴으로 가능.
- **명령어들의 상대 주소 결정**
  - 각 기호 표를 만들어 각 **기호의 값(상대주소)을 기록**.
- **기호의 재배치 여부 결정**
  - 재배치할 기호를 결정하여 **재배치 여부를 표시**

**2) 패스 2의 기능**
- **명령어 자체를 2진 코드로 대체**
  - **명령어 표**에서 각 명령어의 2진 코드를 찾아 **기계어 코드 생성**
- **명령어의 기호 대신 기호 표에서 찾은 값으로 대체**
  - 기호의 전향 참조가 있을 때는 기호의 값(주소 값)을 찾아 기호 대신 기호 값을 기입.

<br/>

- 어셈블리어 지시어가 ```EQU``` 일 때는 **LC**의 값을 증가 시키지 않는다.
- ```EQU```에 의해 기호 값이 정해지면 이 기호는 기억 장소를 차지 하지 않기 때문이다.

### 자료 구조
**(1) 패스 1이 실행되기 위해서 필요한 입출력 자료 (데이터베이스)**

입력|출력
:---:|:---:|
원시 프로그램<br/>위치계수기(변수)<br/>어셈블러 지시어 & 명령어 표|기호표<br/>오류 정보<br/>원시 프로그램 사본

- 위치 계수기(LC) : 명령어의 주소를 헤아리기 위한 변수
- **기호 표** : 프로그램에 나타난 기호와 정의된 기호의 값을 알기 위해 사용되는 변수

**(2) 패스 2가 실행되기 위해서 필요한 입출력 자료 (데이터베이스)**

입력|출력
:---:|:---:|
원시 프로그램<br/>위치계수기(변수)<br/>어셈블러 지시어 & 명령어 표<br/>기호표|목적 프로그램<br/>오류 정보

- **기호 표** : 프로그램에 나타난 기호와 정의된 기호의 값을 알기 위해 사용되는 변수
- 목적 프로그램 : 번역된 기계어 코드

<br/>

### 연습 문제
**1.** <br/>
```assembly
MOV AX, BX
ADD BX, VALUE
MOV SAVE, BX

VALUE DW 10
SAVE DW ?
END
```

1 ) 이 프로그램을 번역하기 위하여, 어셈블러의 이중 패스 알고리즘을 이용하라. 패스 1이 만드는 기호표를 만들어 보아라. 단, 명령어 MOV와 ADD는 길이가 2바이트씩이라고 가정한다.

상대주소|원시 코드
:---:|:---:|
0|```MOV AX, BX```
2|```ADD BX, VALUE```
4|```MOV SAVE, BX```
6|```VALUE DW 10```
8|```SAVE DW -```

기호|값(상대주소)|재배치 여부
:---:|:---:|:---:|
```VALUE```|6|1
```SAVE```|8|1

2 ) 패스 2가 만드는 목적 프로그램을 만들어 보아라. 단, 명령어의 기계어 코드 대신 니모닉을 사용한다.

상대주소|번역된 코드(니모닉으로 표시)
:---:|:---:|
0|```MOV AX, BX```
2|```ADD BX, [6]```
4|```MOV [8], BX```
6|```10```
8|```-```

3 ) 이 프로그램이 100번지부터 적재 된다면 기억장치 내에 적재된 모양을 보여라.

![6장_어셈블러 설계_연습문제-2](https://user-images.githubusercontent.com/66156026/172644271-2ca1a081-ce75-4f81-8e28-506580d1bb63.jpg)

<br/>

**2.** <br/>
패스 1에서는 기호 표만 만드는 것이 아니라 명령어의 기계어 코드까지 만들 수 있다. 위 1번 문제를 어셈블하고, 이 때 패스 1의 중간 결과와 패스 2의 결과를 보여라.

패스 1 중간 결과

주소|번역된 코드(니모닉으로 표시)
:---:|:---:|
0000|```MOV AX, BX``` 👉🏻 2byte
0002|```ADD BX, VALUE``` 👉🏻 4byte
0006|```MOV SAVE, BX``` 👉🏻 4byte
000A|```VALUE DW 10``` 👉🏻 2byte
000C|```-``` 👉🏻 2byte

기호표

기호|값(주소)|재배치 여부
:---:|:---:|:---:|
```VALUE```|000A|1
```SAVE```|000C|1

패스 2 결과

주소|번역된 코드(니모닉으로 표시)|번역된 코드(기계어 코드로 표시)
:---:|:---:|:---:|
0000|```MOV AX, BX```|```8B C3```
0002|```ADD BX, [000A]```|```03 1E 0A00```
0006|```MOV [000C], BX```|```89 1E 0C00```
000A|```0A00```|```0A00```
000C|```-```|```-```

<br/>

**3.** <br/>
```assembly
MOV AX, F4
ADD AX, F5
ADD AX, F6
MOV SAVE, AX

F4 DW 40
F5 DW 50
F6 DW 60
SAVE DW ?
END
```

1 ) 이 프로그램을 이중패스 알고리즘을 이용하여 어셈블 할 때, 패스 1의 출력을 보여라.

상대주소|원시코드
:---:|:---:|
0000|```MOV AX, F4``` 👉🏻 3byte
0003|```ADD AX, F5``` 👉🏻 4byte
0007|```ADD AX, F6``` 👉🏻 4byte
000B|```MOV SAVE, AX``` 👉🏻 3byte
000E|```F4 DW 40``` 👉🏻 2byte
0010|```F5 DW 50``` 👉🏻 2byte
0012|```F6 DW 60``` 👉🏻 2byte
0014|```SAVE DW ?``` 👉🏻 2byte

기호표

기호|값(주소)|재배치 여부
:---:|:---:|:---:|
```F4```|000E|1
```F5```|0010|1
```F6```|0012|1
```SAVE```|0014|1

2 ) 패스 2의 출력을 보여라.

상대주소|번역된 코드
:---:|:---:|
0000|```A1 000E```
0003|```03 06 0010```
0007|```03 06 0012```
000B|```A3 0014```
000E|```2800```
0010|```3200```
0012|```3C00```
0014|```0000```

3 ) 500h번지에 적재된다고 할 때, 기억장치의 모양을 그림으로 보여라.

![6장_어셈블러 설계_연습문제-3](https://user-images.githubusercontent.com/66156026/172665803-7ce13892-f5c3-4745-8b88-690ba0075aa1.jpg)


