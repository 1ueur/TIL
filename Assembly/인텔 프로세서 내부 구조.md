# 인텔 프로세서의 내부 구조
## 프로세서 구조
8086의 경우 ```20비트``` **주소 버스**, ```16비트``` **데이터 버스**를 사용한다.

데이터 버스의 크기는 판독과 기록 사이클의 횟수를 결정한다. ex) 32비트로 된 자료를 읽기 위해서는 16비트 데이터 버스를 사용하는 8086에서는 **2회**를 읽어야 한다.

### 16비트 인텔 프로세서
![22_시프_3주_1교시_3장인텔프로세서의내부구조(1)-10](https://user-images.githubusercontent.com/66156026/164251361-abfb0ced-2a2f-498a-b6d6-11aa7d76e67b.jpg)

**1단어 = 2byte**

EU(Execution Unit) : 명령어 실행 장치
- 명령을 실행하고 연산
- 8개의 범용 레지스터
- 산술 논리 연산 장치(ALU)
- 플래그(Flags) 레지스터

BIU(Bus Interface Unit) : 버스 인터페이스 장치
- 명령어를 인출(Fetch)
- 기억장치나 입출력장치로부터 데이터를 읽어오거나 출력(RAM과 연결)
- 4개의 세그먼트 레지스터(CS, DS, SS, ES)
- 명령어 포인터(IP)
- 유효 주소 계산을 위한 가산기(Adder)
- 명령어 큐 : 실행할 명령어를 기억 장치로부터 가져와 임시로 저장하는 버퍼

내부버스 : 프로세서 내부에 각 부분 사이의 자료를 전달해주는 버스

### 레지스터의 종류
데이터 레지스터(4개) ```AX```, ```BX```, ```CX```, ```DX``` : **일시적인 결과 기록**

포인터 레지스터(3개) ```SP```, ```BP```, ```IP``` : **스택 포인터와 베이스 포인터**

인덱스 레지스터(2개) ```SI```, ```DI``` : **데이터의 주소 저장**

플래그 레지스터(1개) ```Flags R``` : **연산 결과의 정보 저장**

세그먼트 레지스터(4개) ```CS```, ```DS```, ```SS```, ```ES``` : **세그먼트의 시작 주소 저장**

세그먼트 레지스터는 세그먼트의 시작 주소를 가리킨다. (코드 세그먼트, 데이터 세그먼트, 스택 세그먼트, 여분의 데이터 세그먼트)

### 프로세스의 개념
작업(job) : 실행 프로그램과 이에 필요한 입력 데이터의 묶음. **컴퓨터에 실행 의로되기 전의 상태**

프로세스(process) : 프로그램이 실행되기 위해서는 반드시 **실행되기 전에 주기억장치에 저장**되어야 한다. 커널에 등록된 작업으로 운영체제에 의해 관리된다.

### 플래그 레지스터의 구성
프로그램을 실행할 때 앞의 연산 결과가 음수인지 양수인지, 컴퓨터 사용자가 일반인지 관리자인지 등의 정보를 16비트 크기의 상태 레지스터에 기록되고 이것에 기록되는 각 비트들을 플래그라고 한다.

8086의 9가지 플래그

수치 연산과 논리 연산의 결과에 의한 CPU의 상태를 나타내는 **상태 플래그** : CF, PF, AF, ZF, SF, OF

CPU 동작을 변화하기 위한 **제어 플래그** : TF, IF, DF

### 16 인텔 프로세서의 버스 크기
**데이터 버스**(8086에서는 ```16bits```)

데이터 버스의 크기는 **판독과 기록 사이클의 횟수, WORD(데이터 양)를 결정**한다.
(32비트로 된 자료를 판독하거나 기록할 때 16비트 데이터 버스일 경우 2회 읽는다.)

**주소 버스**(8086에서는 ```20bits```)

주소 버스의 크기는 **최대 기억 장치 주소를 결정**한다.
2^20 = 1,048,576(1MB) 주소를 지정할 수 있다.

### 명령어의 실행 단계
**명령어 인출(IP+2)** - **명령어 해독** - **데이터 인출** - **실행 사이클**

### 명령어의 길이
8비트로 이루어진 명령어를 예로 들어보면, 주소 지정 방식이 4가지, 레지스터가 2개가 있다면 👉🏻 주소 지정에 2비트, 레지스터에 1비트가 필요하다. (3bit)
명령어는 8bit - 3bit = 5bit, 2^5(32)개만 만들 수 있다.

명령어의 길이는 1. 레지스터의 개수 2. 주소 지정 방식의 종류 3. 명령어의 종류에 따라 결정된다.

### 명령어의 형태
**명령어 코드(5bit) + 오퍼랜드(3bit)** = 8bit로 구성된다. 오퍼랜드에는 주소지정방식과 레지스터가 표현된다.

![22_시프_3주_2교시_3장인텔프로세서의내부구조(2)-10](https://user-images.githubusercontent.com/66156026/164258001-92c8234b-8ed9-4f6f-b61b-45970658e09f.jpg)

오퍼랜드의 첫 2bit에는

```00``` 직접 주소지정방식
```01``` 베이스 주소지정방식
```10``` 인덱스 주소지정방식
```11``` 베이스 인덱스 주소지정방식

이 포함되고 남은 1bit에는

```1``` 레지스터 A (AX)
```0``` 레지스터 B (BX)

가 포함된다.

8086 계열 어셈블리어 명령어 크기는 1단어(2바이트)로 기본 구성되며 최대 3단어(6바이트)까지 확장 가능하다.

