![22_시프_10주_3교시_5장매크로프로세서설계3_3-3](https://user-images.githubusercontent.com/66156026/171985067-4a2fe603-dd0a-4adc-916f-29f3f0df9914.jpg)

### 이중패스 알고리즘의 장점
- **매크로 호출이 해당 매크로 정의에 앞서 나타날 수 있다는 점**
  - **전향 참조 처리**는 어셈블리 언어 프로그램에서는 반드시 필요하다.
  - 매크로 처리 시에는 그렇게 중요하지 않다.
  - 모든 매크로는 호출되기 이전에 반드시 정의 되어야 한다는 제약을 두어 전향 참조를 금지한다.
  - 두 개의 패스를 묶어 하나의 패스를 처리한다.
- 단일 패스 알고리즘은 입력된 프로그램을 두 번 처리해야 하는 번거로움을 없애고 매크로의 정의와 호출이 서로 섞여서 수행된다.
- 매크로 내에서의 매크로 호출, 다중 매크로 정의도 가능하게 하는 이점이 존재한다.

## 이중패스 매크로 프로세서 알고리즘
```assembly
AA MACRO A, B
    MOV AX, A
    ADD AX, B
    MOV A, AX
ENDM
.
AA X, Y
.
X DW 50
Y DW 100
```

**1) 패스 1**
- 매크로 정의
- MNTC = 1, MDTC = 1 가정
- 패스 1에서 형식인수표, MNT, MDT를 만든다.

① MNTC 👈🏻 1

② MDTC 👈🏻 1

③ ```AA MACRO A, B``` 를 읽음

④ IF (MACRO 지시어) 발견

⑤ 매크로 이름(AA)과 MDTC(1)를 MNT와 MNTC(1)번째 행에 기록

**[매크로 이름표(MNT)]**

색인(MNTC)|매크로 이름|MDT 색인(MDTC)
:---:|:---:|:---:|
1|```AA```|1

⑥ MNTC 👈🏻 MNTC + 1  ;2

⑦ 형식 인수표 작성

**[형식 인수표]**

형식 인수 이름|색인 번호
:---:|:---:|
```A```|#0
```B```|#1

⑧ 매크로 이름이 있는 줄을 MDT와 MDTC(1)행에 기록

⑨ MDTC 👈🏻 MDTC + 1  ;2

- 문장 속의 형식 인수를 색인 번호로 치환 (MDT 작성)

**[매크로 정의표(MDT)]**

색인(MDTC)|문장
:---:|:---:|
1|```AA MACRO A, B```
2|```MOV AX, #0```
3|```ADD AX, #1```
4|```MOV #0, AX```
5|```ENDM```
6|

⑩ ENDM을 MDT의 MDTC(5)행에 기록

⑪ MDTC 👈🏻 MDTC + 1  ;6

**2) 패스 2**
- 매크로 호출
- ```AA X, Y```

① 다음 명령어를 읽었는데 이것이 ```AA```이다.

② IF (매크로 호출), MNT에서 ```AA```를 찾았다.

③ MDTP 👈🏻 1 (MNT 내의 MDT 색인 값)

④ 실 인수표 작성(실 인수에 색인 번호 부여)

**[실 인수표]**

색인 번호|실 인수이름
:---:|:---:|
#0|```X```
#1|```Y```

⑤ MDTP 👈🏻 MDTP + 1  ;2

⑥ MDT에서 MDTP(2)번째 문장을 읽음. 즉, ```MOV AX, #0```

⑦ 문장 내의 인수 색인 번호를 실 인수로 치환. 읽은 문장에 있는 인수 번호 #0에 해당되는 실 인수 ```X```를 치환.

⑧ 확장된 명령어 출력. 즉, ```MOV AX, X```

⑤ ~ ⑧ 을 반복하여 <br/>
```assembly
ADD AX, Y
MOV X, AX
```
를 출력한다.

❗️ **[확장된 결과]**
```assembly
MOV AX, X
ADD AX, Y
MOV X, AX
```
